---
### **Propósito:** REGRESION LINEAL.
```
---
title: "04 - Regresión Lineal"
output: html_document
---

```{r}
source("../origen/config.R")
source("../origen/modeling_utils.R")
```

####### Regresión lineal #######
# 1. CARGA Y PREPARACIÓN DE DATOS 

```{r}
message("Cargando los dataframes finales procesados...")
train_full <- readRDS(here::here("data", "processed", "train_final.rds"))

# -- Limpieza de Outliers y preparación del dataframe --
q_low  <- quantile(train_full$price, 0.01, na.rm = TRUE)
q_high <- quantile(train_full$price, 0.99, na.rm = TRUE)
vivienda_bogota <- train_full %>%
  filter(price >= q_low & price <= q_high) %>%
  # Creamos una variable de precio en millones para que los números sean más manejables
  mutate(preciom = price / 1e6) %>%
  # Renombramos 'surface_total' para que coincida con tu ejemplo
  rename(areaconst = surface_total) %>%
  # Filtramos NAs en las variables que vamos a usar
  filter(!is.na(preciom), !is.na(areaconst))

message(paste("Datos listos con", nrow(vivienda_bogota), "observaciones."))


# -- PREPARACIÓN DEL TEST SET --
# Es crucial aplicar las mismas transformaciones.
# Imputamos NAs en 'areaconst' del test set con la mediana del train set.
median_area_train <- median(train_learner$areaconst, na.rm = TRUE)

test_learner <- test_full %>%
  mutate(preciom = NA) %>% # No tenemos el precio aquí
  rename(areaconst = surface_total) %>%
  mutate(areaconst = ifelse(is.na(areaconst), median_area_train, areaconst))

message(paste("Datos de entrenamiento listos con", nrow(train_learner), "observaciones."))
message(paste("Datos de prueba listos con", nrow(test_learner), "observaciones."))
```

# 2.  AJUSTE Y ANÁLISIS DE DIFERENTES MODELOS LINEALES

```{r}
message("\n--- Modelo 1: price ~ area ---")
modelo1 <- lm(preciom ~ areaconst, data = vivienda_bogota)

# Resumen del modelo
print(summary(modelo1))

# Intervalos de confianza para los coeficientes
cat("\nIntervalos de Confianza para los Coeficientes (Modelo 1):\n")
print(confint(modelo1))
```

```{r}
message("\n--- Modelo 2: log(price) ~ log(area) ---")
# Añadimos 1 para evitar log(0) si hubiera áreas de 0
modelo2 <- lm(log(preciom) ~ log(areaconst + 1), data = vivienda_bogota)
print(summary(modelo2))
```

```{r}
message("\n--- Modelo 3: log(price) ~ area ---")
modelo3 <- lm(log(preciom) ~ areaconst, data = vivienda_bogota)
print(summary(modelo3))
```


```{r}
message("\n--- Modelo 4: price ~ log(area) ---")
modelo4 <- lm(preciom ~ log(areaconst + 1), data = vivienda_bogota)
print(summary(modelo4))
```


# 3. COMPARACIÓN DE MODELOS Y SELECCIÓN DEL MEJOR

```{r}
# -- COMPARACIÓN CON AIC --
# El Criterio de Información de Akaike (AIC) nos ayuda a comparar modelos.
# El modelo con el AIC más bajo es el preferido.
aic_results <- AIC(modelo1, modelo2, modelo3, modelo4)
cat("\n--- Comparación de Modelos por AIC (menor es mejor) ---\n")
print(aic_results)

# Seleccionamos el mejor modelo (el que tiene el menor AIC)
best_model_name <- rownames(aic_results)[which.min(aic_results$AIC)]
cat("\nEl mejor modelo simple es:", best_model_name, "\n")
best_simple_model <- get(best_model_name)
```

# 4. PREDICCIÓN CON EL MEJOR MODELO SIMPLE

```{r}
message("\nGenerando predicciones con el mejor modelo simple...")

# Verificamos si el mejor modelo predice el logaritmo del precio
predicts_log <- str_detect(as.character(formula(best_simple_model)), "log") |> any()
predicts_log <- isTRUE(predicts_log)   # Garantiza longitud 1

# Hacemos la predicción en el set de prueba
predictions_simple_raw <- predict(best_simple_model, newdata = test_learner)

# Convertimos las predicciones a la escala original de precios
if (predicts_log) {
  # Si el modelo predijo log(preciom), revertimos la transformación
  precios_finales_simple <- exp(predictions_simple_raw) * 1e6
} else {
  # Si el modelo predijo preciom, solo multiplicamos por 1 millón
  precios_finales_simple <- predictions_simple_raw * 1e6
}

# Creamos el dataframe de submission
submission_simple <- tibble(
  property_id = test_learner$property_id,
  price = precios_finales_simple
)

# Guardamos el archivo
ruta_destino <- here::here("outputs", "kaggle_submissions")
dir.create(ruta_destino, showWarnings = FALSE, recursive = TRUE)
ruta_archivo_submission <- here::here(ruta_destino, "submission_simple_linear.csv")
write_csv(submission_simple, ruta_archivo_submission)

message(paste0("\nArchivo de submission del modelo simple guardado en:\n", ruta_archivo_submission))
cat("\nResumen de precios predichos (Modelo Simple):\n")
summary(submission_simple$price)

```

# 5. MODELO DE REGRESIÓN MÚLTIPLE

```{r}
# Un modelo con una sola variable es una buena base, pero para una mejor
# predicción, debemos usar más información.

message("\n\n--- Entrenando un Modelo de Regresión Lineal Múltiple más potente... ---")

# Seleccionamos un conjunto más rico de variables
features_multiples <- c(
  "surface_total", "bedrooms", "bathrooms", "estrato",
  "latitude", "longitude", "property_type", "localidad"
)

# Creamos la fórmula SIN transformación en la variable respuesta
model_formula_multi <- as.formula(
  paste("price ~", paste(features_multiples, collapse = " + "))
)

# Creamos la receta, aplicando log(price) correctamente
rec_multi <- recipe(model_formula_multi, data = train_full) %>%
  step_log(price, skip = TRUE) %>%                               
  step_other(localidad, threshold = 0.01) %>%
  step_dummy(all_nominal_predictors(), one_hot = TRUE) %>%
  step_zv(all_predictors())

# Especificamos el modelo, lo unimos al workflow y lo entrenamos
lm_spec <- linear_reg() %>% set_engine("lm")
lm_workflow <- workflow() %>% add_recipe(rec_multi) %>% add_model(lm_spec)
final_lm_fit <- fit(lm_workflow, data = train_full)

# --- Predicción con el Modelo Múltiple ---
message("Generando predicciones con el modelo múltiple...")

log_predictions_multi <- predict(final_lm_fit, new_data = test_full)

# Convertimos de logaritmo a precio original
precios_finales_multi <- exp(log_predictions_multi$.pred)

# Creamos el dataframe de submission
submission_multiple <- tibble(
  property_id = test_full$property_id,
  price = precios_finales_multi
)

# Guardamos el archivo
ruta_archivo_submission_multi <- here::here(ruta_destino, "submission_multiple_linear.csv")
write_csv(submission_multiple, ruta_archivo_submission_multi)
message(paste0("\nArchivo de submission del modelo múltiple guardado en:\n", ruta_archivo_submission_multi))

cat("\nResumen de precios predichos (Modelo Múltiple):\n")
summary(submission_multiple$price)

```


```{r}
message("\nDefiniendo una receta de preprocesamiento avanzada...")

# -------------------------------
# 1) VARIABLES
# -------------------------------

features <- c(
  "surface_total", "bedrooms", "bathrooms", "estrato",
  "latitude", "longitude", "property_type", "localidad",
  "has_parqueadero_garaje", "has_ascensor", "has_terraza"
)

vars_necesarias_test <- c(features, "property_id", "surface_covered","dist_autopistas","dist_centros_comerciales", "dist_parques")

# Reconstruimos test_learner GARANTIZANDO todas las columnas
test_learner <- test_final[, vars_necesarias_test, drop = FALSE]

# -------------------------------
# 2) ASEGURAR QUE TRAIN Y TEST TIENEN MISMO NIVELES FACTOR
# -------------------------------


categorical_features <- c("property_type", "localidad", "estrato")

for (v in categorical_features) {
  lvls <- union(levels(as.factor(train_learner[[v]])),
                levels(as.factor(test_learner[[v]])))
  train_learner[[v]] <- factor(train_learner[[v]], levels = lvls)
  test_learner[[v]]  <- factor(test_learner[[v]],  levels = lvls)
}


# -------------------------------
# 3) CREAR FORMULA CORRECTA
# -------------------------------

model_formula <- as.formula(
  paste("price ~", paste(features, collapse = " + "))
)

# -------------------------------
# 4) RECIPE AVANZADA
# -------------------------------

rec_avanzada <- recipe(model_formula, data = train_learner) %>%
  
  # Transformación de la variable objetivo (solo en training)
  step_log(price, skip = TRUE) %>%
  
  # Transformación log predictores sesgados
  step_log(surface_total, offset = 1) %>%
  
  # Winsorizing ESTABLE (basado en percentiles del training)
  step_mutate_at(
    surface_total,
    fn = function(x) {
      p <- quantile(x, 0.98, na.rm = TRUE)
      pmin(x, p)
    }
  ) %>%
  
  # Categóricas
  step_other(localidad, threshold = 0.02, other = "otra_localidad") %>%
  step_novel(all_nominal_predictors()) %>%
  step_dummy(all_nominal_predictors(), one_hot = TRUE) %>%
  
  # Interacciones
  step_interact(terms = ~ starts_with("surface_total") : starts_with("estrato_")) %>%
  step_interact(terms = ~ starts_with("surface_total") : starts_with("localidad_")) %>%
  
  # Limpieza final
  step_zv(all_predictors()) %>%
  step_center(all_numeric_predictors()) %>%
  step_scale(all_numeric_predictors())

# No se usa prep(): workflows lo hacen automáticamente
# prep_rec <- prep(rec_avanzada, training = train_learner)  # ← SE ELIMINA

# -------------------------------
# 5) WORKFLOW + MODELO
# -------------------------------

lm_spec <- linear_reg() %>% set_engine("lm")

lm_workflow <- workflow() %>%
  add_recipe(rec_avanzada) %>% 
  add_model(lm_spec)

# -------------------------------
# 6) ENTRENAMIENTO
# -------------------------------

message("\nEntrenando el modelo lineal potenciado...")
final_fit <- fit(lm_workflow, data = train_learner)
message("Modelo entrenado.")

# -------------------------------
# 7) PREDICCIÓN FINAL
# -------------------------------

message("Generando predicciones en el set de prueba...")

log_predictions <- predict(final_fit, new_data = test_learner)

# Convertimos de log a la escala original
precios_finales <- exp(log_predictions$.pred)

# -------------------------------
# 8) CREAR SUBMISSION
# -------------------------------

submission <- tibble(
  property_id = test_learner$property_id,
  price = precios_finales
)

ruta_destino <- here::here("outputs", "kaggle_submissions")
dir.create(ruta_destino, showWarnings = FALSE, recursive = TRUE)

ruta_archivo_submission <- here::here(ruta_destino, "submission_lm_potenciado.csv")
write_csv(submission, ruta_archivo_submission)

message(paste0("\nArchivo de submission guardado en:\n", ruta_archivo_submission))

cat("\n--- Resumen de Precios Predichos (Modelo Potenciado) ---\n")
summary(submission$price)

cat("\n--- Resumen en Millones de Pesos ---\n")
summary(submission$price / 1e6)

# -------------------------------
# 9) Histograma
# -------------------------------
ggplot(submission, aes(x = price / 1e6)) +
  geom_histogram(bins = 50, fill = "deepskyblue3", alpha = 0.7) +
  geom_vline(xintercept = 200, color = "red", linetype = "dashed", size = 1) +
  labs(
    title = "Distribución de Precios Predichos",
    subtitle = "La línea roja marca los 200 millones",
    x = "Precio Predicho (en Millones de Pesos)",
    y = "Frecuencia"
  ) +
  theme_minimal()

```











